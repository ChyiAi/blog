<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[MyISAM]]></title>
    <url>%2Fblog%2F2019%2F07%2F18%2Fmysql-myisam%2F</url>
    <content type="text"><![CDATA[MyISAM存储引擎官方文档]]></content>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Innodb]]></title>
    <url>%2Fblog%2F2019%2F07%2F18%2Fmysql-innodb%2F</url>
    <content type="text"><![CDATA[Innodb存储引擎官方文档 特性完整的支持]]></content>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mysql问题汇总]]></title>
    <url>%2Fblog%2F2019%2F07%2F18%2Fmysql%2F</url>
    <content type="text"><![CDATA[索引 部分官方文档解读 存储引擎 Feature InnoDB MyISAM Default （after5.58version）✅ （before5.58version）❌ Transaction ✅ ❌ Index Cached ✅ ✅ Data Cached ✅ ❌ Clustered Indexes ✅ ❌ B-tree ✅ ✅ Hash-tree ✅ ❌ clustered indexes :聚合索引，按主键顺序排序 Innodb MyISAM ACIDwiki/ACID]]></content>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Instruction list]]></title>
    <url>%2Fblog%2F2019%2F04%2F25%2Fjvm_instruction%2F</url>
    <content type="text"><![CDATA[JVM Instruction]]></content>
      <tags>
        <tag>jvm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JLS阅读笔记]]></title>
    <url>%2Fblog%2F2019%2F03%2F22%2Fjls%2F</url>
    <content type="text"><![CDATA[本文Java Language Specification作为读本，提炼了部分章节知识点 Thread and LocksSynchronization原文中介绍synchronizad时，提到了synchronized implement using monitors。 Monitorsynchronizad synchronizad statement， 先计算对象索引，在锁操作完成之后，synchronized修饰的statement才会执行，并且解锁操作是通过同一个monitor自动执行。 synchronized method，被synchronized修饰的method被调用前，执行锁操作，方法体直到锁操作结束才会执行。如果这个方法是实例方法，则锁这个被调用的方法的实例的monitor1]]></content>
      <tags>
        <tag>读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构]]></title>
    <url>%2Fblog%2F2019%2F02%2F28%2Fdata_structure%2F</url>
    <content type="text"><![CDATA[树二叉树二叉搜索树（binary search tree）]]></content>
      <tags>
        <tag>DataStructure</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法]]></title>
    <url>%2Fblog%2F2019%2F02%2F15%2Falgorithm%2F</url>
    <content type="text"><![CDATA[一致性hash]]></content>
      <tags>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[索引]]></title>
    <url>%2Fblog%2F2019%2F02%2F15%2Fmysql-index%2F</url>
    <content type="text"><![CDATA[mysql官方文档对于索引的描述]]></content>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[maven]]></title>
    <url>%2Fblog%2F2019%2F02%2F02%2Fmaven%2F</url>
    <content type="text"><![CDATA[123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;settings xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/settings-1.0.0.xsd&quot;&gt; &lt;!--本地仓库。该值表示构建系统本地仓库的路径。其默认值为$&#123;user.home&#125;/.m2/repository。 --&gt; &lt;localRepository&gt;usr/local/maven&lt;/localRepository&gt; &lt;!--Maven是否需要和用户交互以获得输入。如果Maven需要和用户交互以获得输入，则设置成true，反之则应为false。默认为true。 --&gt; &lt;interactiveMode&gt;true&lt;/interactiveMode&gt; &lt;!--Maven是否需要使用plugin-registry.xml文件来管理插件版本。 --&gt; &lt;!--如果设置为true，则在&#123;user.home&#125;/.m2下需要有一个plugin-registry.xml来对plugin的版本进行管理 --&gt; &lt;!--默认为false。 --&gt; &lt;usePluginRegistry&gt;false&lt;/usePluginRegistry&gt; &lt;!--表示Maven是否需要在离线模式下运行。如果构建系统需要在离线模式下运行，则为true，默认为false。 --&gt; &lt;!--当由于网络设置原因或者安全因素，构建服务器不能连接远程仓库的时候，该配置就十分有用。 --&gt; &lt;offline&gt;false&lt;/offline&gt; &lt;!--当插件的组织Id（groupId）没有显式提供时，供搜寻插件组织Id（groupId）的列表。 --&gt; &lt;!--该元素包含一个pluginGroup元素列表，每个子元素包含了一个组织Id（groupId）。 --&gt; &lt;!--当我们使用某个插件，并且没有在命令行为其提供组织Id（groupId）的时候，Maven就会使用该列表。 --&gt; &lt;!--默认情况下该列表包含了org.apache.maven.plugins。 --&gt; &lt;pluginGroups&gt; &lt;!--plugin的组织Id（groupId） --&gt; &lt;pluginGroup&gt;org.codehaus.mojo&lt;/pluginGroup&gt; &lt;/pluginGroups&gt; &lt;!--用来配置不同的代理，多代理profiles可以应对笔记本或移动设备的工作环境： 通过简单的设置profile id就可以很容易的更换整个代理配置。 --&gt; &lt;proxies&gt; &lt;!--代理元素包含配置代理时需要的信息 --&gt; &lt;proxy&gt; &lt;!--代理的唯一定义符，用来区分不同的代理元素。 --&gt; &lt;id&gt;myproxy&lt;/id&gt; &lt;!--该代理是否是激活的那个。true则激活代理。当我们声明了一组代理，而某个时候只需要激活一个代理的时候，该元素就可以派上用处。 --&gt; &lt;active&gt;true&lt;/active&gt; &lt;!--代理的协议。 协议://主机名:端口，分隔成离散的元素以方便配置。 --&gt; &lt;protocol&gt;http://…&lt;/protocol&gt; &lt;!--代理的主机名。协议://主机名:端口，分隔成离散的元素以方便配置。 --&gt; &lt;host&gt;proxy.somewhere.com&lt;/host&gt; &lt;!--代理的端口。协议://主机名:端口，分隔成离散的元素以方便配置。 --&gt; &lt;port&gt;8080&lt;/port&gt; &lt;!--代理的用户名，用户名和密码表示代理服务器认证的登录名和密码。 --&gt; &lt;username&gt;proxyuser&lt;/username&gt; &lt;!--代理的密码，用户名和密码表示代理服务器认证的登录名和密码。 --&gt; &lt;password&gt;somepassword&lt;/password&gt; &lt;!--不该被代理的主机名列表。该列表的分隔符由代理服务器指定；例子中使用了竖线分隔符，使用逗号分隔也很常见。 --&gt; &lt;nonProxyHosts&gt;*.google.com|ibiblio.org&lt;/nonProxyHosts&gt; &lt;/proxy&gt; &lt;/proxies&gt; &lt;!--配置服务端的一些设置。一些设置如安全证书不应该和pom.xml一起分发。这种类型的信息应该存在于构建服务器上的settings.xml文件中。 --&gt; &lt;servers&gt; &lt;!--服务器元素包含配置服务器时需要的信息 --&gt; &lt;server&gt; &lt;!--这是server的id（注意不是用户登陆的id），该id与distributionManagement中repository元素的id相匹配。 --&gt; &lt;id&gt;server001&lt;/id&gt; &lt;!--鉴权用户名。鉴权用户名和鉴权密码表示服务器认证所需要的登录名和密码。 --&gt; &lt;username&gt;my_login&lt;/username&gt; &lt;!--鉴权密码 。鉴权用户名和鉴权密码表示服务器认证所需要的登录名和密码。 --&gt; &lt;password&gt;my_password&lt;/password&gt; &lt;!--鉴权时使用的私钥位置。和前两个元素类似，私钥位置和私钥密码指定了一个私钥的路径（默认是/home/hudson/.ssh/id_dsa）以及如果需要的话，一个密钥 --&gt; &lt;!--将来passphrase和password元素可能会被提取到外部，但目前它们必须在settings.xml文件以纯文本的形式声明。 --&gt; &lt;privateKey&gt;$&#123;usr.home&#125;/.ssh/id_dsa&lt;/privateKey&gt; &lt;!--鉴权时使用的私钥密码。 --&gt; &lt;passphrase&gt;some_passphrase&lt;/passphrase&gt; &lt;!--文件被创建时的权限。如果在部署的时候会创建一个仓库文件或者目录，这时候就可以使用权限（permission）。--&gt; &lt;!--这两个元素合法的值是一个三位数字，其对应了unix文件系统的权限，如664，或者775。 --&gt; &lt;filePermissions&gt;664&lt;/filePermissions&gt; &lt;!--目录被创建时的权限。 --&gt; &lt;directoryPermissions&gt;775&lt;/directoryPermissions&gt; &lt;!--传输层额外的配置项 --&gt; &lt;configuration&gt;&lt;/configuration&gt; &lt;/server&gt; &lt;/servers&gt; &lt;!--为仓库列表配置的下载镜像列表。 --&gt; &lt;mirrors&gt; &lt;!--给定仓库的下载镜像。 --&gt; &lt;mirror&gt; &lt;!--该镜像的唯一标识符。id用来区分不同的mirror元素。 --&gt; &lt;id&gt;planetmirror.com&lt;/id&gt; &lt;!--镜像名称 --&gt; &lt;name&gt;PlanetMirror Australia&lt;/name&gt; &lt;!--该镜像的URL。构建系统会优先考虑使用该URL，而非使用默认的服务器URL。 --&gt; &lt;url&gt;http://downloads.planetmirror.com/pub/maven2&lt;/url&gt; &lt;!--被镜像的服务器的id。例如，如果我们要设置了一个Maven中央仓库（http://repo1.maven.org/maven2）的镜像，--&gt; &lt;!--就需要将该元素设置成central。这必须和中央仓库的id central完全一致。 --&gt; &lt;mirrorOf&gt;central&lt;/mirrorOf&gt; &lt;/mirror&gt; &lt;/mirrors&gt; &lt;!--根据环境参数来调整构建配置的列表。settings.xml中的profile元素是pom.xml中profile元素的裁剪版本。--&gt; &lt;!--它包含了id，activation, repositories, pluginRepositories和 properties元素。--&gt; &lt;!--这里的profile元素只包含这五个子元素是因为这里只关心构建系统这个整体（这正是settings.xml文件的角色定位），而非单独的项目对象模型设置。--&gt; &lt;!--如果一个settings中的profile被激活，它的值会覆盖任何其它定义在POM中或者profile.xml中的带有相同id的profile。 --&gt; &lt;profiles&gt; &lt;!--根据环境参数来调整的构件的配置 --&gt; &lt;profile&gt; &lt;!--该配置的唯一标识符。 --&gt; &lt;id&gt;test&lt;/id&gt; &lt;!--自动触发profile的条件逻辑。Activation是profile的开启钥匙。--&gt; &lt;!--如POM中的profile一样，profile的力量来自于它能够在某些特定的环境中自动使用某些特定的值；这些环境通过activation元素指定。--&gt; &lt;!--activation元素并不是激活profile的唯一方式。settings.xml文件中的activeProfile元素可以包含profile的id。--&gt; &lt;!--profile也可以通过在命令行，使用-P标记和逗号分隔的列表来显式的激活（如，-P test）。 --&gt; &lt;activation&gt; &lt;!--profile默认是否激活的标识 --&gt; &lt;activeByDefault&gt;false&lt;/activeByDefault&gt; &lt;!--activation有一个内建的java版本检测，如果检测到jdk版本与期待的一样，profile被激活。 --&gt; &lt;jdk&gt;1.7&lt;/jdk&gt; &lt;!--当匹配的操作系统属性被检测到，profile被激活。os元素可以定义一些操作系统相关的属性。 --&gt; &lt;os&gt; &lt;!--激活profile的操作系统的名字 --&gt; &lt;name&gt;Windows XP&lt;/name&gt; &lt;!--激活profile的操作系统所属家族(如 &apos;windows&apos;) --&gt; &lt;family&gt;Windows&lt;/family&gt; &lt;!--激活profile的操作系统体系结构 --&gt; &lt;arch&gt;x86&lt;/arch&gt; &lt;!--激活profile的操作系统版本 --&gt; &lt;version&gt;5.1.2600&lt;/version&gt; &lt;/os&gt; &lt;!--如果Maven检测到某一个属性（其值可以在POM中通过$&#123;名称&#125;引用），其拥有对应的名称和值，Profile就会被激活。--&gt; &lt;!--如果值字段是空的，那么存在属性名称字段就会激活profile，否则按区分大小写方式匹配属性值字段 --&gt; &lt;property&gt; &lt;!--激活profile的属性的名称 --&gt; &lt;name&gt;mavenVersion&lt;/name&gt; &lt;!--激活profile的属性的值 --&gt; &lt;value&gt;2.0.3&lt;/value&gt; &lt;/property&gt; &lt;!--提供一个文件名，通过检测该文件的存在或不存在来激活profile。missing检查文件是否存在，如果不存在则激活profile。--&gt; &lt;!--另一方面，exists则会检查文件是否存在，如果存在则激活profile。 --&gt; &lt;file&gt; &lt;!--如果指定的文件存在，则激活profile。 --&gt; &lt;exists&gt;/usr/local/hudson/hudson-home/jobs/maven-guide-zh-to-production/workspace/&lt;/exists&gt; &lt;!--如果指定的文件不存在，则激活profile。 --&gt; &lt;missing&gt;/usr/local/hudson/hudson-home/jobs/maven-guide-zh-to-production/workspace/&lt;/missing&gt; &lt;/file&gt; &lt;/activation&gt; &lt;!--对应profile的扩展属性列表。Maven属性和Ant中的属性一样，可以用来存放一些值。这些值可以在POM中的任何地方使用标记$&#123;X&#125;来使用，这里X是指属性的名称。--&gt; &lt;!--属性有五种不同的形式，并且都能在settings.xml文件中访问。 --&gt; &lt;!--1. env.X: 在一个变量前加上&quot;env.&quot;的前缀，会返回一个shell环境变量。例如,&quot;env.PATH&quot;指代了$path环境变量（在Windows上是%PATH%）。 --&gt; &lt;!--2. project.x：指代了POM中对应的元素值。 --&gt; &lt;!--3. settings.x: 指代了settings.xml中对应元素的值。 --&gt; &lt;!--4. Java System Properties: 所有可通过java.lang.System.getProperties()访问的属性都能在POM中使用该形式访问， --&gt; &lt;!-- 如/usr/lib/jvm/java-1.6.0-openjdk-1.6.0.0/jre。 --&gt; &lt;!--5. x: 在&lt;properties/&gt;元素中，或者外部文件中设置，以$&#123;someVar&#125;的形式使用。 --&gt; &lt;properties&gt; &lt;!-- 如果这个profile被激活，那么属性$&#123;user.install&#125;就可以被访问了 --&gt; &lt;user.install&gt;usr/local/winner/jobs/maven-guide&lt;/user.install&gt; &lt;/properties&gt; &lt;!--远程仓库列表，它是Maven用来填充构建系统本地仓库所使用的一组远程项目。 --&gt; &lt;repositories&gt; &lt;!--包含需要连接到远程仓库的信息 --&gt; &lt;repository&gt; &lt;!--远程仓库唯一标识 --&gt; &lt;id&gt;codehausSnapshots&lt;/id&gt; &lt;!--远程仓库名称 --&gt; &lt;name&gt;Codehaus Snapshots&lt;/name&gt; &lt;!--如何处理远程仓库里发布版本的下载 --&gt; &lt;releases&gt; &lt;!--true或者false表示该仓库是否为下载某种类型构件（发布版，快照版）开启。 --&gt; &lt;enabled&gt;false&lt;/enabled&gt; &lt;!--该元素指定更新发生的频率。Maven会比较本地POM和远程POM的时间戳。这里的选项是：--&gt; &lt;!--always（一直），daily（默认，每日），interval：X（这里X是以分钟为单位的时间间隔），或者never（从不）。 --&gt; &lt;updatePolicy&gt;always&lt;/updatePolicy&gt; &lt;!--当Maven验证构件校验文件失败时该怎么做:--&gt; &lt;!--ignore（忽略），fail（失败），或者warn（警告）。 --&gt; &lt;checksumPolicy&gt;warn&lt;/checksumPolicy&gt; &lt;/releases&gt; &lt;!--如何处理远程仓库里快照版本的下载。有了releases和snapshots这两组配置，POM就可以在每个单独的仓库中，为每种类型的构件采取不同的策略。--&gt; &lt;!--例如，可能有人会决定只为开发目的开启对快照版本下载的支持。参见repositories/repository/releases元素 --&gt; &lt;snapshots&gt; &lt;enabled /&gt; &lt;updatePolicy /&gt; &lt;checksumPolicy /&gt; &lt;/snapshots&gt; &lt;!--远程仓库URL，按protocol://hostname/path形式 --&gt; &lt;url&gt;http://snapshots.maven.codehaus.org/maven2&lt;/url&gt; &lt;!--用于定位和排序构件的仓库布局类型-可以是default（默认）或者legacy（遗留）。--&gt; &lt;!--Maven 2为其仓库提供了一个默认的布局；然而，Maven 1.x有一种不同的布局。我们可以使用该元素指定布局是default（默认）还是legacy（遗留）。 --&gt; &lt;layout&gt;default&lt;/layout&gt; &lt;/repository&gt; &lt;/repositories&gt; &lt;!--发现插件的远程仓库列表。仓库是两种主要构件的家。第一种构件被用作其它构件的依赖。这是中央仓库中存储的大部分构件类型。另外一种构件类型是插件。--&gt; &lt;!--Maven插件是一种特殊类型的构件。由于这个原因，插件仓库独立于其它仓库。pluginRepositories元素的结构和repositories元素的结构类似。--&gt; &lt;!--每个pluginRepository元素指定一个Maven可以用来寻找新插件的远程地址。 --&gt; &lt;pluginRepositories&gt; &lt;!--包含需要连接到远程插件仓库的信息.参见profiles/profile/repositories/repository元素的说明 --&gt; &lt;pluginRepository&gt; &lt;releases&gt; &lt;enabled /&gt; &lt;updatePolicy /&gt; &lt;checksumPolicy /&gt; &lt;/releases&gt; &lt;snapshots&gt; &lt;enabled /&gt; &lt;updatePolicy /&gt; &lt;checksumPolicy /&gt; &lt;/snapshots&gt; &lt;id /&gt; &lt;name /&gt; &lt;url /&gt; &lt;layout /&gt; &lt;/pluginRepository&gt; &lt;/pluginRepositories&gt; &lt;!--手动激活profiles的列表，按照profile被应用的顺序定义activeProfile。 该元素包含了一组activeProfile元素，每个activeProfile都含有一个profile id。--&gt; &lt;!--任何在activeProfile中定义的profile id，不论环境设置如何，其对应的 profile都会被激活。--&gt; &lt;!--如果没有匹配的profile，则什么都不会发生。例如，env-test是一个activeProfile，则在pom.xml（或者profile.xml）中对应id的profile会被激活。--&gt; &lt;!--如果运行过程中找不到这样一个profile，Maven则会像往常一样运行。 --&gt; &lt;activeProfiles&gt; &lt;activeProfile&gt;env-test&lt;/activeProfile&gt; &lt;/activeProfiles&gt; &lt;/profile&gt; &lt;/profiles&gt;&lt;/settings&gt;]]></content>
      <tags>
        <tag>build tool</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Annotation]]></title>
    <url>%2Fblog%2F2019%2F01%2F30%2Fannotation%2F</url>
    <content type="text"><![CDATA[声明12public @interface TestAnnotation &#123;&#125; 元注解 Annotation 参数 描述 @Retention 限定元数据的存活时间 RetentionPolicy.SOURCE 注解只在源码阶段保留，在编译器进行编译时它将被丢弃忽视 RetentionPolicy.CLASS 注解只被保留到编译进行的时候，它并不会被加载到 JVM 中 RetentionPolicy.RUNTIME 注解可以保留到程序运行的时候，它会被加载进入到 JVM 中 @Documented 注解的元数据将添加到Javadoc中 @Target 注解运用位置 ElementType.ANNOTATION_TYPE 为注解进行注解 ElementType.CONSTRUCTOR 可以给构造方法进行注解 ElementType.FIELD 可以给属性进行注解 ElementType.LOCAL_VARIABLE 可以给局部变量进行注解 ElementType.METHOD 可以给方法进行注解 ElementType.PACKAGE 可以给一个包进行注解 ElementType.PARAMETER 可以给一个方法内的参数进行注解 ElementType.TYPE 可以给一个类型进行注解，比如类、接口、枚举 @Inherited 表明注解可以集成 @Repeatable 可重复注解 调用Class类中有如下方法：123456789101112public Annotation[] getAnnotations()Description copied from interface: AnnotatedElementReturns all annotations present on this element. (Returns an array of length zero if this element has no annotations.) The caller of this method is free to modify the returned array; it will have no effect on the arrays returned to other callers.Specified by:getAnnotations in interface AnnotatedElementReturns:all annotations present on this elementSince:1.5 12345678910111213public boolean isAnnotationPresent(Class&lt;? extends Annotation&gt; annotationClass)Description copied from interface: AnnotatedElementReturns true if an annotation for the specified type is present on this element, else false. This method is designed primarily for convenient access to marker annotations.Specified by:isAnnotationPresent in interface AnnotatedElementParameters:annotationClass - the Class object corresponding to the annotation typeReturns:true if an annotation for the specified annotation type is present on this element, else falseThrows:NullPointerException - if the given annotation class is nullSince:1.5 以上两个方法可以获取注解类的相关信息]]></content>
      <tags>
        <tag>JLS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[多线程]]></title>
    <url>%2Fblog%2F2019%2F01%2F29%2Fthread%2F</url>
    <content type="text"><![CDATA[涉及到多线程的理论始终不够清晰条理，索性总结一篇以自勉分享一个有趣的图文博客 定义Wiki: In computer science, a thread of execution is the smallest sequence of programmed instructions that can be managed independently by a scheduler, which is typically a part of the operating system. The implementation of threads and processes differs between operating systems, but in most cases a thread is a component of a process. Multiple threads can exist within one process, executing concurrently and sharing resources such as memory, while different processes do not share these resources. In particular, the threads of a process share its executable code and the values of its variables at any given time. 简述wiki的描述：线程是进程的组件，同进程内线程共享资源。随之产生的概念：并发：同一时间只有一个cpu实例访问并行：同一时间可以有个cpu实例访问引用示例简图 线程安全涉及到事务的概念 transaction 线程同步单一时间内并发访问。e.g. synchronized关键字 线程各状态转换引用api说明 方法名 简介摘要 总结 start() 线程起点 //调用run(); join() 等待直到线程死亡 //使用wait();实现 sleep() 睡眠暂停线程，依赖系统调度 wait() 继承自object，等待直到其他线程invoke notify(); or notifyAll(); notify() 继承自object，唤醒一个等待该object的线程，与等待的其他线程共同竞争 notifyAll() 唤醒所有等待 … yield() 注释说的比较难理解。简单解释为，让行。执行该方法的线程并没有释放锁，只是让scheduler把它的优先级放后 Monitor看完上表，在官方注释中有一个重要的概念，monitor（监视器、监视锁）。引用stackoverflow的回答：Java中Object本身即Monitor对象，它会关联每个对象。了解了monitor的基本定义，上面的表格中还体现出一个问题。wait();notify();notifyAll();三个方法并不属于thread类而是Object对象的方法。这里也可以体现出Object即Monitor的理论。 synchronized摘自oralce官方文档，提炼几个关键点： 最基本的同步就是使用monitor实现（也验证了上面每个对象都关联Monitor的说法） synchronized statement 会计算对象引用，直到运行完成。 synchronized method 当方法被调用就锁定，如果执行方法的是instance则锁定关联instance的monitor，如果方法是static的则锁定关联的class object的monitor，如果正在执行的方法完成了，则自动解锁。 ThreadPool这里主要由ThreadPoolExecutor展开分析：1234567891011121314151617181920212223242526272829303132/** * Creates a new &#123;@code ThreadPoolExecutor&#125; with the given initial * parameters and default thread factory and rejected execution handler. * It may be more convenient to use one of the &#123;@link Executors&#125; factory * methods instead of this general purpose constructor. * * @param corePoolSize the number of threads to keep in the pool, even * if they are idle, unless &#123;@code allowCoreThreadTimeOut&#125; is set * @param maximumPoolSize the maximum number of threads to allow in the * pool * @param keepAliveTime when the number of threads is greater than * the core, this is the maximum time that excess idle threads * will wait for new tasks before terminating. * @param unit the time unit for the &#123;@code keepAliveTime&#125; argument * @param workQueue the queue to use for holding tasks before they are * executed. This queue will hold only the &#123;@code Runnable&#125; * tasks submitted by the &#123;@code execute&#125; method. * @throws IllegalArgumentException if one of the following holds:&lt;br&gt; * &#123;@code corePoolSize &lt; 0&#125;&lt;br&gt; * &#123;@code keepAliveTime &lt; 0&#125;&lt;br&gt; * &#123;@code maximumPoolSize &lt;= 0&#125;&lt;br&gt; * &#123;@code maximumPoolSize &lt; corePoolSize&#125; * @throws NullPointerException if &#123;@code workQueue&#125; is null */ public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue) &#123; this(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue, Executors.defaultThreadFactory(), defaultHandler); &#125; ThreadPoolExecutor 构造函数源代码中有几个核心参数，corePoolSize(核心线程数)、maximumPoolSize(线程池最大允许线程数量)、keepAliveTime(当线程数量大与核心线程数时，线程等待的最大时间)123456789101112131415161718192021222324252627282930313233343536373839public void execute(Runnable command) &#123; if (command == null) throw new NullPointerException(); /* * Proceed in 3 steps: * * 1. If fewer than corePoolSize threads are running, try to * start a new thread with the given command as its first * task. The call to addWorker atomically checks runState and * workerCount, and so prevents false alarms that would add * threads when it shouldn&apos;t, by returning false. * * 2. If a task can be successfully queued, then we still need * to double-check whether we should have added a thread * (because existing ones died since last checking) or that * the pool shut down since entry into this method. So we * recheck state and if necessary roll back the enqueuing if * stopped, or start a new thread if there are none. * * 3. If we cannot queue task, then we try to add a new * thread. If it fails, we know we are shut down or saturated * and so reject the task. */ int c = ctl.get(); if (workerCountOf(c) &lt; corePoolSize) &#123; if (addWorker(command, true)) return; c = ctl.get(); &#125; if (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123; int recheck = ctl.get(); if (! isRunning(recheck) &amp;&amp; remove(command)) reject(command); else if (workerCountOf(recheck) == 0) addWorker(null, false); &#125; else if (!addWorker(command, false)) reject(command); &#125; 从ThreadPoolExecutor的execute方法注解我们可以分析线程池的三步执行方法： 如果线程数少于corePoolSize，那么尝试用给定的命令开启一个线程。 任务排队成功，仍然需要进行double-check，来确保是否添加线程。 如果无法给任务排队，那么将尝试创建新的线程。如果创建失败，则拒绝该任务。参考博文 最后转一篇习题]]></content>
  </entry>
  <entry>
    <title><![CDATA[锁]]></title>
    <url>%2Fblog%2F2019%2F01%2F29%2Flock%2F</url>
    <content type="text"></content>
      <tags>
        <tag>Idea</tag>
        <tag>macOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[微服务]]></title>
    <url>%2Fblog%2F2019%2F01%2F28%2Fmicro_service%2F</url>
    <content type="text"><![CDATA[概述网关（路由）熔断处理负载均衡注册中心微服务架构的核心模块，拥戴搭载注册和订阅的服务 EurekaEureka ZookeeperDubbo 服务调用方式]]></content>
      <tags>
        <tag>架构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[网络协议模型]]></title>
    <url>%2Fblog%2F2018%2F12%2F28%2Fnetwork_model%2F</url>
    <content type="text"><![CDATA[Open System Interconnection 描述 相关协议 物理层 在物理介质上以二进制形式传递数据 集线器、网线、hub、Rj45，802.3 数据链路层 通信的实体间建立数据链路（数据分桢、流控、物理寻址） 网卡、网桥、 Rj45，802.3 网络层 数据在结点之间创建逻辑链路，并分组转发数据（端对端建立链接，数据包选择路由） 多层交换机、路由、防火墙、Ip等 传输层 提供应用进程之间的逻辑通信（建立链接、处理数据包错误、数据包次序） TCP、UDP、进程、socket 会话层 建立端链接并提供访问验证和会话（session） RPC、SQL、服务器校验用户信息等 表示层 数据格式转换（数据加密、解密，图片解码、编码，数据压缩等等） URL加密 应用层 访问网络服务的接口等等 Telnet、FTP、HTTP 需求的循序渐进展开讲解 最初科学家要解决的第一个问题是，两个硬件之间怎么通信。具体就是一台发些比特流，然后另一台能收到。（即数模转换，0、1转换成电流的强弱，到达目标后转换为0、1） –物理层 通过电线我能发数据流了，但是，我还希望通过无线电波，通过其它介质来传输。然后我还要保证传输过去的比特流是正确的，要有纠错功能。 –链路层 现在我能发正确的发比特流数据到另一台计算机了，但是当我发大量数据时候，可能需要好长时间，例如一个视频格式的，网络会中断好多次（事实上，即使有了物理层和数据链路层，网络还是经常中断，只是中断的时间是毫秒级别的）。那么，我还须要保证传输大量文件时的准确性。于是，我要对发出去的数据进行封装。就像发快递一样，一个个地发。 –传输层 传输层只是解决了打包的问题。但是如果我有多台计算机，怎么找到我要发的那台？或者，A要给F发信息，中间要经过B，C，D,E，但是中间还有好多节点如K.J.Z.Y。我怎么选择最佳路径？这就是路由要做的事。 –网络层 现在我们已经保证给正确的计算机，发送正确的封装过后的信息了。但是用户级别的体验好不好？难道我每次都要调用TCP去打包，然后调用IP协议去找路由，自己去发？当然不行，所以我们要建立一个自动收发包，自动寻址的功能。 –会话层 现在我能保证应用程序自动收发包和寻址了。但是我要用Linux给window发包，两个系统语法不一致，就像安装包一样，exe是不能在linux下用的，shell在window下也是不能直接运行的。 –表示层 上述必要条件如何展现 –应用层]]></content>
      <tags>
        <tag>network</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[知识体系]]></title>
    <url>%2Fblog%2F2018%2F12%2F21%2Fsite_content%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[Redis]]></title>
    <url>%2Fblog%2F2018%2F12%2F20%2Fredis%2F</url>
    <content type="text"><![CDATA[官网安装mac 上安装 redis 首先必须保证mac 已经安装 xcode. 因为make时要用到 Xcode 的command Tools . 下载 redis 1234$ wget http://download.redis.io/releases/redis-4.0.2.tar.gz$ tar xzf redis-4.0.2.tar.gz$ cd redis-4.0.2$ make 修改文件夹名并编译12345$ mv redis-2.8.7 redis$ cd redis/$ sudo make$ sudo make test$ sudo make isntall 配置config1$ vim /usr/local/redis-4.0.2/redis.conf 找到dir ./这一行配置。此配置是将内存中的数据写入一个文件，这个数据库文件要保存到什么地方。我在mac根目录下创建了 /Users/***/develop/config/redis的文件夹（注意此文件夹必须有可读写权限）所以这一行的配置是 dir /Users/***/develop/config/redis修改后保存配置文件，同时将配置文件移动到 /etc 目录下.1sudo mv redis.conf /etc 上面第三步 make install成功后，你就应该在这个目录下看到redis1/usr/local/bin/redis-server 尝试启动一下 redis12cd /usr/local/bin./redis-server /etc/redis.conf conf文件相关配置 功能 操作实现 设置线程守护模式(后台启动) daemonize=yes 设置进程锁文件 pidfile /usr/local/redis/redis.pid port 6379 timeout 300 日志级别 loglevel debug 日志位置 logfile /usr/local/redis/log-redis.log 指定本地数据库路径 dir /usr/local/redis/db/ 设置数据库的数量，默认数据库为0，可以使用SELECT 命令在连接上指定数据库id databases 8 注：标红参数要注意修改，否则注意查看报错日志，redis是否已启动 redis-cli命令总结 功能 命令 远程链接 redis-cli -h {host} -p {port} {command} 关闭 redis-cli shutdown homebrew安装1234567891011➜ bin brew install redis==&gt; Downloading https://homebrew.bintray.com/bottles/redis-4.0.10.high_sierra.bottle.tar.gz######################################################################## 100.0%==&gt; Pouring redis-4.0.10.high_sierra.bottle.tar.gz==&gt; CaveatsTo have launchd start redis now and restart at login: brew services start redisOr, if you don&apos;t want/need a background service you can just run: redis-server /usr/local/etc/redis.conf==&gt; Summary🍺 /usr/local/Cellar/redis/4.0.10: 13 files, 2.8MB]]></content>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mac环境软件安装汇总]]></title>
    <url>%2Fblog%2F2018%2F12%2F20%2Fenvironment%2F</url>
    <content type="text"><![CDATA[开发环境HomebrewRed hat有yum，Ubuntu有apt-get而mac第三方支持：Homebrew简称brew， 是Mac OSX上的软件包管理工具，能在Mac中方便的安装软件或者卸载软件默认安装路径为：/usr/loacl/Cellar brew 相关命令 安装任意包 brew install [packageName] 安装wget brew install wget 卸载任意包 brew uninstall [packageName] 卸载git brew uninstall git 查询可用包 brew search [packageName] 查看已安装包列表 brew info [packageName] 删除该gem包 gem uninstall [gemname] 删除某指定版本gem gem uninstall [gemname] –version=[ver] 更新Homebrew brew update 查看Homebrew版本 brew -v [packageName] Homebrew帮助信息 brew -h [packageName] ruby(脚本语言)1234ruby -e &quot;$(curl -fsSL &lt;https://raw.githubusercontent.com/Homebrew/install/master/install&gt;)&quot; ==&gt;This script will install: /usr/local/bin/brew /usr/local/Library/... /usr/local/share/man/man1/brew.1 123456789Press RETURN to continue or any other key to abort ==&gt;Downloading and installing Homebrew... remote: Counting objects: 3693, done. remote: Compressing objects: 100% (3525/3525), done. remote: Total 3693 (delta 38), reused 527 (delta 27), pack-reused 0 Receiving objects: 100% (3693/3693), 3.04 MiB | 79.00 KiB/s, done. Resolving deltas: 100% (38/38), done. From &lt;https://github.com/Homebrew/homebrew&gt; [new branch] master -&gt; origin/master HEAD is now at 9c41fb8 update man page ==&gt;Installation successful! ==&gt; Next steps Run `brew help` to get started gem(ruby程序的包管理器类似Homebrew) 国内源站 gem 相关命令 查看源列表 gem sources -l 将源移除 gem sources –remove https://rubygems.org/ 添加国内源 gem sources –add https://gems.ruby-china.org/ 缓存 gem sources -u 查看gem安装环境（gem命令安装的软件在 GEM PATHS 中的lib path目录gems文件夹下） gem environment jekyll (git page)1gem install jekyll secureCRT123456789101、下载破解文件 securecrt_mac_crack.pl2、在终端执行命令。（请注意对应文件的目录） sudo perl ~/Downloads/securecrt_mac_crack.pl /Applications/SecureCRT.app/Contents/MacOS/SecureCRT等到出现了 crack successful就可以了，终端不要关闭3、打开SecureCRT，点击Enter License Data.. 输入刚才终端的数据就完成了破解，破解信息在刚才终端窗口，你的可能和我的不一样，以终端显示的为准。（请注意逐一拷贝，不要一次拷贝）Name: bleedfly Company: bleedfly.comSerial Number: 03-29-002542License Key: ADGB7V 9SHE34 Y2BST3 K78ZKF ADUPW4 K819ZW 4HVJCE P1NYRCIssue Date: 09-17-2013 launching rocket1A Mac PreferencePane for managing services with launchd.]]></content>
      <tags>
        <tag>Idea</tag>
        <tag>macOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[The Little Redis Book]]></title>
    <url>%2Fblog%2F2018%2F12%2F20%2Fredisbook%2F</url>
    <content type="text"><![CDATA[The Little Redis Book (Free Book, 2012) by Karl Seguin is a great free and concise book that will get you started with Redis.本书为Redis官网推荐的免费书籍。 The Basics]]></content>
      <tags>
        <tag>读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[macOS系统目录]]></title>
    <url>%2Fblog%2F2018%2F12%2F18%2FmacOS%2F</url>
    <content type="text"><![CDATA[摘录自官方文档 目录 官方描述 简述 /Applications This directory is where you install apps intended for use by all users of a computer. The App Store installs apps purchased by the user in this directory automatically. app存储目录 Library There are multiple Library directories on the system, each one associated with a different domain or specific user. Apps should use the Library directory to store app-specific (or system-specific) resources. 资源目录，很多目录的子目录下都有关联的library /Network This directory contains the list of computers in the local area network. 网络相关 /System This directory contains the system resources required by macOS to run. These resources are provided by Apple and must not be modified.This directory comprises the contents of the system domain. macOS运行所需资源目录 /Users This directory contains one or more user home directories. The user home directory is where user-related files are stored. A typical user’s home directory includes the following subdirectories:Applications—Contains user-specific apps.Desktop—Contains the items on the user’s desktop.Downloads—Contains files downloaded from the Internet.Library—Contains user-specific app files (hidden in macOS 10.7 and later).Movies—Contains the user’s video files.Music—Contains the user’s music files.Pictures—Contains the user’s photos.Public—Contains content the user wants to share.Sites—Contains web pages used by the user’s personal site. (Web Sharing must be enabled to display these pages.) 用户目录 unix文件介绍 MAC下如何显示隐藏文件12345//在终端上输入以下命令 &gt; defaults write com.apple.finder AppleShowAllFiles -bool true//重新启动Finder &gt; 使用快捷键 Command + Option + esc或者执行 killall Finder命令 这样就可以显示隐藏文件了。//不显示隐藏文件的命令为 &gt; defaults write com.apple.finder AppleShowAllFiles -bool false同样也需要东西启动Finder才生效。]]></content>
      <tags>
        <tag>macOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[本站 搭建教程]]></title>
    <url>%2Fblog%2F2018%2F12%2F15%2Fsite_doc%2F</url>
    <content type="text"><![CDATA[简介搭建博客的心由来已久，本篇文章为记录搭建过程。博客引擎 Hexo 模版 next，搭建系统环境为macOS MoJave 10.14.2，详细文档请移步官网。 配置安装环境 安装git 安装Node.js 安装Hexo 创建博客目录进入到要创建博客的工作目录，例如：$ cd /User/username/WorkSpaces123$ hexo init blog$ cd blog$ npm install blog目录结构 目录名称 描述 themes 主题安装目录 source 资源文件夹 source/_posts 文章资源文件夹 Hexo创建文件命令由于init命令是创建极简博客环境，所以标签tags、分类categories、关于about均没有对应目录，需要用到以下命令：1$ hexo new [layout] &lt;title&gt; 布局 layout 三种类型见官网123$ hexo new page tags$ hexo new page categories$ hexo new page about 创建完以上三个文件在 blog/source 目录下有对应文件生成，修改文件source/about/index.md中type类型为aboutsource/tags/index.md中type类型为tagssource/categories/index.md中type类型为categories 主题 下载nextHexo 官网有大量的主题提供下载，这里以 next 为例12$ cd blog$ git clone https://github.com/theme-next/hexo-theme-next themes/next 配置在下载完 next 主题之后，进入 themes/next目录，可以看到_config.yml文件 配置主题风格123456789# ---------------------------------------------------------------# Scheme Settings# ---------------------------------------------------------------# Schemesscheme: Muse#scheme: Mist#scheme: Pisces#scheme: Gemini 以上四种主题风格可自行选择，详见官方文档 配置标签tags、分类categories、关于about目录123456789menu: home: / || home #about: /about/ || user #tags: /tags/ || tags #categories: /categories/ || th archives: /archives/ || archive #schedule: /schedule/ || calendar #sitemap: /sitemap.xml || sitemap #commonweal: /404/ || heartbeat 取消tags、categories、about的注释 配置语言环境这里要注意配置语言环境需要在blog/_config.yml文件中配置，而在blog/themes/next/_config.yml中是不起作用的 12# language: enlanguage: zh-Hans 设置博客目录hexo在本地环境运行时将占用4000端口，地址为：http://localhost:4000，但是实际部署情况，你可能需要自定义根目录，例如：http://localhost:4000/blog 那么需要修改 _config.yml 文件中的 root: / 为 root: /blog 拓展功能 搜索 分享 脑图插件由于next主题本身并没有脑图插件，笔者这里使用可以转化markdown语法的百度kityminder插件为例配置next 根据 kityminder 的github仓库的介绍，安装 bower，及 kity 所有的依赖，找到生成的 kity.min.js 备用next 开发目录简介1234- layout //布局文件夹- scripts //脚本文件夹- source //资源文件夹 - lib //第三方库 加载js文件 在 source/lib 目录下，创建 kityminder 文件夹，copy kityminder.core.min.js， kity.min.js 至此 在 layout/_script/vendors.swig 文件中，添加如下内容： 1234&#123;% if theme.kityminder %&#125; &#123;% set js_vendors.kity = &apos;kityminder/kity.min.js?v=1.0.0&apos; %&#125; &#123;% set js_vendors.kityminder = &apos;kityminder/kityminder.core.min.js?v=1.0.0&apos; %&#125;&#123;% endif %&#125; 上步中的全局变量，需要配置在 _config.yml 中 12# minderkityminder: true 加载css样式 在 layout/_partials/head.siwg 文件中添加 1234&#123;% if theme.kityminder %&#125; &#123;% set kityminder_css_uri = url_for(theme.vendors._internal + &apos;/kityminder/kityminder.core.css?v=1.0.0&apos;) %&#125; &lt;link href=&quot;&#123;&#123; kityminder_css_uri &#125;&#125;&quot; rel=&quot;stylesheet&quot; type=&quot;text/css&quot; /&gt;&#123;% endif %&#125; 上步中的全局变量，需要配置在 _config.yml 中 12# minderkityminder: true 可能会遇到的问题：该插件配置完成之后，实际使用当中可能会调整css文件，由于用到pullquote代码块，所以需要修改source/css/_common/scaffolding/helpers.styl中pullquote样式 初始化 打开 layout/_layout.swig 文件在如下位置添加 12345...&#123;% include &apos;_third-party/scroll-cookie.swig&apos; %&#125;&#123;% include &apos;_third-party/exturl.swig&apos; %&#125;...&#123;% include &apos;_third-party/kityminder.swig&apos; %&#125; //添加 在 layout/_third-party下，添加第二步中的 kityminder.swig 文件，内容如下： 123&#123;% if theme.kityminder %&#125; &lt;script type=&quot;text/javascript&quot; src=&quot;&#123;&#123; url_for(theme.js) &#125;&#125;/src/kityminder.js?v=&#123;&#123; theme.version &#125;&#125;&quot;&gt;&lt;/script&gt;&#123;% endif %&#125; 在 source/js/src下，添加第三步中的 kityminder.js 文件，用来初始化kityminder组件： 123456789101112$(document).ready(function()&#123; var minder = new kityminder.Minder(&#123; renderTo: &apos;.kitycontainer&apos; &#125;); var markdownText = $(&apos;.kitycontainer&apos;).text().trim(); $(&apos;.kitycontainer p&apos;).each(function(index, element) &#123; element.style.display = &apos;none&apos;; &#125;); minder.importData(&apos;markdown&apos;, markdownText); minder.disable(); minder.execCommand(&apos;hand&apos;);&#125;) 初始化完成后，可以通过hexo引用pullquote代码块（因为此代码块可以加载我们在js中初始化的容器 kity的kitycontainer class），实际效果如下 #example ##一级分支 ##一级分支 ###二级分支 ##一级分支 ##一级分支 ##一级分支 ##一级分支 ###二级分支 ####三级分支 本地部署hexo命令123$ hexo g // 生成静态文件$ hexo s // 启动服务可添加启动参数//访问地址 http://localhost:4000/ 服务器自动部署安装部署插件 hexo-deployer-git1$ npm install hexo-deployer-git --save 在blog/_config.yml中添加配置12345678910deploy: type: git // 单环境配置 repo: &lt;repository url&gt; // 多环境配置 repo: github: &lt;github repository url&gt; gitee: &lt;gitee repository url&gt; branch: [branch] message: [message] 配置完成执行命令hexo deploy]]></content>
  </entry>
  <entry>
    <title><![CDATA[git]]></title>
    <url>%2Fblog%2F2018%2F12%2F13%2Fgit%2F</url>
    <content type="text"><![CDATA[init1git init set up your git name and email123git config --local user.name clongcgit config --local user.email clongc1988@163.comgit remote add origin https://github.com/DeeMoxa/blog.git show global config123456// 查看系统configgit config --system --list// 查看当前用户globalgit config --global --list// 查看当前仓库配置git config --local --list store user credential1git config credential.helper store add folder to my staging area1git add FOLDERNAME commit the folder1git commit -m &quot;add FOLDERNAME&quot; Clone1git clone https://github.com/clone Clone the repository at “REPOSITORY” to “my_cloned_repo”.1git clone https://github.com/clone my_cloned_repo status of someone in the files1git status rename move12git mv file_A.txt file_B.txtgit mv file_A.txt file_B.txt src investigate the log of repository1git log tag the current commit with ‘new_tag’1git tag &apos;new_tag&apos; push tag int remote repository1git push --tags origin master some files missing from the commit and add the missing file12git add missingfilegit commit --amend -m &apos;修正&apos; commit with The date1git commit --date=05.26.2017T15:00:00 -m anshitijiao unstage file under the situation of commit error1git reset HEAD fileName undo the last commit1git reset --soft HEAD~1 checkout the file from the last commit1git checkout FILENAME find the remote repository1git remote -v pull changes from origin repository1git pull origin master rebase location branch from origin/master and push it12345git rebase origin/master//git rebase onto A B C 把B到C段的commit 提交到A //p.s. rebase --onto的机制是左开右闭//即，不包含B 包含Cgit push origin master there have been modifications since your last commit . find out which line1git diff find out anybody modify the file1git blame FILENAME create new branch TEST1git branch TEST delete the branch1git branch -d BRANCHNAME merge the branch to the currently branch1git merge BRANCHNAME get origin but don’t merge it1git fetch origin reset HEAD origin by force.1234567git checkout .git fetch --allgit reset --hard origin/master// orgit fetch --all git reset --hard origin/mastergit pull]]></content>
  </entry>
  <entry>
    <title><![CDATA[Intellij Idea 使用常见问题总结]]></title>
    <url>%2Fblog%2F2018%2F12%2F13%2Fidea%2F</url>
    <content type="text"><![CDATA[Plugins 安装插件Settings/Preference ⌘, -&gt; Plugins -&gt; Install plugin from disk.. （选择下载完成的jar） 浏览插件Settings/Preference ⌘, -&gt; Plugins -&gt; Browse repositories.. ToolBars在工具栏添加自定义按钮（以添加git工具push按钮为例）Settings/Preference ⌘, -&gt; Appearance &amp; Behavior -&gt; Menus and Toolbars -&gt; Navigation Bar Toolbar -&gt; NavBarVcsGroup由于git组件按钮属于Navigation Bar所以在这里添加 通过Add After找到push按钮 mac下 idea debugger 加载慢的问题]]></content>
      <tags>
        <tag>Idea</tag>
      </tags>
  </entry>
</search>
